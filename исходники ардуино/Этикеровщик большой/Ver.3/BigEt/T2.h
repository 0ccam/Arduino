
#define OC1A  9
#define OC2A  11 // Выход таймера 2 (генератора)

volatile byte ctr = 0;
volatile byte queue[4] = {0,0,0,0}; // Очередь срабатываний датчика бутылок.

volatile byte stage = 0;
volatile unsigned int A = 290;
volatile unsigned int B = 260;
volatile unsigned int C = 30;
volatile unsigned int T = 1000;
volatile byte V0 = 1250/55;
volatile byte V1 = 1250/15;
volatile byte Vtask; // Задание скорости, к которому стремиться фактическая скорость.

volatile boolean state = false;

volatile unsigned int tmp

void setup() {
  Serial.begin(9600);
  //Serial.println(TIMSK1);
  pinMode (LED_BUILTIN, OUTPUT);
  pinMode (OC2A, OUTPUT); // Выход Таймера 2.
  attachInterrupt(0, BottleSensor, FALLING); // Назначение обработчика прерывания по падающему фронту на ножке D2.

  InitTimers();
  Pause(1);
  OCR2A = 55; // Частота обновления скорости (ускорение).  
}

void loop(){
  //digitalWrite(LED_BUILTIN, HIGH);
}

void InitTimers(void){
  /* Timer 0 */
  TCCR0A = 0; // Обычный режим.
  OCR0A = 255; // 
  TIMSK0 = (1<<OCIE0A); // Прерывание по совпадению.
  TCCR0B = (1<<WGM02) | (1<<CS02) | (0<<CS01) | (1<<CS00); // CRC режим, предделитель 1024.
  /* Timer 1. Сброс управляющих регистров. */
  TCCR1A = 0; // Переход в общий режим. Значение при запуске контроллера: 0b00000001 - режим ШИМ.   
  TCCR1B = 0; // Выключение таймера. Значение при запуске контроллера: 0b00000011 - запущен с предделителем 64.
  /* Timer 2. Сброс управляющих регистров. */
  TCCR2A = 0; // Переход в общий режим. Значение при запуске контроллера: 0b00000001 - режим ШИМ.  
  TCCR2B = 0; // Выключение таймера. Значение при запуске контроллера: 0b00000100 - запущен с предделителем 64.
}

void Stepper(unsigned int distance, byte speed){
  /*  Timer 1 */
  TCNT1 = 0; // Начальное значение счётчика.
  OCR1A = distance; // Порог сброса счётчика, и генерации прерывания.
  TCCR1B = (1<<WGM12) | (1<<CS12) | (1<<CS11) | (1<<CS10); // CRC режим, внешний источник тактового сигнала.
  TIMSK1 = (1 << OCIE1A); // Включить прерывание по совпадению со счётчиком.
  /* Timer 2 */
  TCNT2 = 0; // Начальное значение счётчика.
  OCR2A  = 255 - speed; // Установка длительности импульсов.
  /*  Режим генерации.
   *  COM2A0=1 - Изменение состояния вывода OC2A на противоположное при совпадении с регистром OCR2A.
   *  WGM22:0=010 - Режим обновления счётчика TCNT2 при совпадении с регистром OCR2A (СRС режим).
   */
  TCCR2A = (1<<COM2A0) | (1<<WGM21);
  TCCR2B = (0<<CS22) | (1<<CS21) | (1<<CS20); // Установка предделителя на 64, и разрешение генерации.
}

void Pause(unsigned int time_ms){
  /*  Timer 1 */
  TCNT1 = 0; // Начальное значение счётчика.
  OCR1A = time_ms << 4; // Порог сброса счётчика, и генерации прерывания. Время(мс) * 16.
  TCCR1B = (1<<WGM12) | (1<<CS12) | (0<<CS11) | (1<<CS10); // CRC режим, предделитель 1024.
  TIMSK1 = (1 << OCIE1A); // Включить прерывание по совпадению со счётчиком.
}

// Обработчик прерывания Таймера 1 (счётчик шагов).
ISR(TIMER1_COMPA_vect){
  TCCR2B = 0; // Остановка генератора (Таймер 2).
  TIMSK1 = 0; // Выключить прерывания Таймера 1.
  TCCR1B = (0<<CS12) | (0<<CS11) | (0<<CS10); // Выключить таймер 1.
}

// Обработчик прерывания Таймера 0 (системный таймер).
ISR(TIMER0_COMPA_vect){
  for (byte i = 0; i < 4; i++){
    if (queue[i] != 0){
      if (queue[i] == 1){
        if (LState == PODACHA){
          Serial.println("Ошибка. Частая подача бутылки!");
          //Error(1);
        }else{
          LState = PODACHA;
        }
      }
      queue[i]--;
    }
  }
}

void BottleSensor(){ // Обработчик датчика бутылки.
  /* Ищет свободное место в очереди, и добавляет в неё
   * новое событие от датчика бутылки со значением
   * времени задержи до подачи этикетки.
   */
  for (byte i = 0; i <= 4; i++){
    if (i == 8){ // Счетчик вышел за пределы очереди.
      Serial.println("Ошибка: Очередь заполнена.");
      //Error(0);
      break;
    }
    if (queue[i] == 0){ // Первая попавшаяся ячейка пуста.
      queue[i] = feed_delay;
      break;
    }
  }
}
